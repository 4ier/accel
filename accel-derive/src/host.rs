use proc_macro2::{Span, TokenStream};
use quote::quote;

/// Split argument type list from the kernel definition
///
/// - Lifetime of any reference will be rewrite into `'arg` to match `Launchable<'arg>`
///   implementaion
fn get_input_types(func: &syn::ItemFn) -> Vec<syn::Type> {
    func.sig
        .inputs
        .iter()
        .map(|arg| match arg {
            &syn::FnArg::Typed(ref val) => {
                match val.ty.as_ref() {
                    // For fundamental types (e.g. i32) and pointer (e.g. *const i32)
                    t @ syn::Type::Path(_) | t @ syn::Type::Ptr(_) => t.clone(),

                    // For slice types &[T]
                    syn::Type::Reference(r) => {
                        let mut r = r.clone();
                        // overwrite the lifetime of argument to match `Launchable<'arg>`
                        // implementation
                        r.lifetime = Some(syn::Lifetime::new("'arg", Span::call_site()));
                        syn::Type::Reference(r)
                    }
                    _ => panic!("Unsupported arugment type"),
                }
            }
            _ => panic!("Unsupported kernel input type sigunature"),
        })
        .collect()
}

/// Generate `mod #kernel_name { ... }`
fn impl_submodule(ptx_str: &str, func: &syn::ItemFn) -> TokenStream {
    let ident = &func.sig.ident;
    let input_types = get_input_types(func);
    let kernel_name = quote! { #ident }.to_string();
    quote! {
        /// Auto-generated by accel-derive
        mod #ident {
            use ::accel::driver::{module, context};
            pub const PTX_STR: &'static str = #ptx_str;

            pub struct Module<'ctx>(module::Module<'ctx>);

            impl<'ctx> Module<'ctx> {
                pub fn new(ctx: &'ctx context::Context) -> ::anyhow::Result<Self> {
                    Ok(Module(module::Module::from_str(ctx, PTX_STR)?))
                }
            }

            impl<'arg, 'ctx> module::Launchable<'arg> for Module<'ctx> {
                type Args = (#(&'arg #input_types,)*);
                fn get_kernel(&self) -> ::anyhow::Result<module::Kernel> {
                    Ok(self.0.get_kernel(#kernel_name)?)
                }
            }
        }
    }
}

/// Generate `fn #kernel_name(...) {...}`
fn caller(func: &syn::ItemFn) -> TokenStream {
    let vis = &func.vis;
    let ident = &func.sig.ident;
    let fn_token = &func.sig.fn_token;
    let input_types = get_input_types(func);
    quote! {
        #vis #fn_token #ident<'arg>(
            ctx: & ::accel::driver::context::Context,
            grid: ::accel::Grid,
            block: ::accel::Block,
            args: &(#(&'arg #input_types,)*)
        ) -> ::anyhow::Result<()> {
            use ::accel::driver::module::Launchable;
            let module = #ident::Module::new(&ctx)?;
            module.launch(grid, block, args)?;
            Ok(())
        }
    }
}

pub fn func2caller(ptx_str: &str, func: &syn::ItemFn) -> TokenStream {
    let impl_submodule = impl_submodule(ptx_str, func);
    let caller = caller(func);
    quote! {
        #impl_submodule
        #caller
    }
}

#[cfg(test)]
mod tests {
    use anyhow::Result;
    use std::{
        io::Write,
        process::{Command, Stdio},
    };

    const TEST_KERNEL: &'static str = r#"
    fn kernel_name(arg1: i32, arg2: f64) {}
    "#;

    /// Format TokenStream by rustfmt
    ///
    /// This can test if the input TokenStream is valid in terms of rustfmt.
    fn pretty_print(tt: &impl ToString) -> Result<()> {
        let mut fmt = Command::new("rustfmt")
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .spawn()?;
        fmt.stdin
            .as_mut()
            .unwrap()
            .write(tt.to_string().as_bytes())?;
        let out = fmt.wait_with_output()?;
        println!("{}", String::from_utf8_lossy(&out.stdout));
        Ok(())
    }

    #[test]
    fn impl_submodule() -> Result<()> {
        let func: syn::ItemFn = syn::parse_str(TEST_KERNEL)?;
        let ts = super::impl_submodule("", &func);
        pretty_print(&ts)?;
        Ok(())
    }

    #[test]
    fn caller() -> Result<()> {
        let func: syn::ItemFn = syn::parse_str(TEST_KERNEL)?;
        let ts = super::caller(&func);
        pretty_print(&ts)?;
        Ok(())
    }
}
