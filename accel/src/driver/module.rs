//! Resource of CUDA middle-IR (PTX/cubin)
//!
//! This module includes a wrapper of `cuLink*` and `cuModule*`
//! in [CUDA Driver APIs](http://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__MODULE.html).

use super::{cuda_driver_init, kernel::Kernel, linker::*};
use crate::{error::*, ffi_call, ffi_call_unsafe};
use anyhow::Result;
use cuda::*;
use std::{ffi::CString, os::raw::c_void, path::Path, ptr::null_mut};

/// OOP-like wrapper of `cuModule*` APIs
#[derive(Debug)]
pub struct Module(CUmodule);

impl Module {
    /// integrated loader of Data
    pub fn load(data: &Data) -> Result<Self> {
        match *data {
            Data::PTX(ref ptx) => unsafe {
                let cstr = CString::new(ptx.as_bytes()).expect("Invalid PTX String");
                Self::load_data(cstr.as_ptr() as _)
            },
            Data::Cubin(ref bin) => unsafe {
                let ptr = bin.as_ptr() as *mut _;
                Self::load_data(ptr)
            },
            Data::PTXFile(ref path) | Data::CubinFile(ref path) => Self::load_file(path),
        }
    }

    /// Wrapper for `cuModuleLoadData`
    unsafe fn load_data(ptr: *const c_void) -> Result<Self> {
        let mut handle = null_mut();
        let m = &mut handle as *mut CUmodule;
        cuda_driver_init();
        ffi_call!(cuModuleLoadData, m, ptr)?;
        Ok(Module(handle))
    }

    /// Wrapper for `cuModuleLoad`
    pub fn load_file(path: &Path) -> Result<Self> {
        let mut handle = null_mut();
        let m = &mut handle as *mut CUmodule;
        let filename = CString::new(path.to_str().unwrap()).expect("Invalid Path");
        cuda_driver_init();
        ffi_call_unsafe!(cuModuleLoad, m, filename.as_ptr())?;
        Ok(Module(handle))
    }

    pub fn from_str(ptx: &str) -> Result<Self> {
        let data = Data::ptx(ptx);
        Self::load(&data)
    }

    /// Wrapper of `cuModuleGetFunction`
    pub fn get_kernel<'m>(&'m self, name: &str) -> Result<Kernel<'m>> {
        let name = CString::new(name).expect("Invalid Kernel name");
        let mut func = null_mut();
        cuda_driver_init();
        ffi_call_unsafe!(
            cuModuleGetFunction,
            &mut func as *mut CUfunction,
            self.0,
            name.as_ptr()
        )?;
        Ok(Kernel { func, _m: self })
    }
}

impl Drop for Module {
    fn drop(&mut self) {
        ffi_call_unsafe!(cuModuleUnload, self.0).expect("Failed to unload module");
    }
}

#[cfg(test)]
mod tests {
    use super::super::device::*;
    use super::*;

    #[test]
    fn load_do_nothing() -> anyhow::Result<()> {
        // generated by do_nothing example in accel-derive
        let ptx = r#"
        .version 3.2
        .target sm_30
        .address_size 64
        .visible .entry do_nothing()
        {
          ret;
        }
        "#;
        let device = Device::nth(0)?;
        let _ctx = device.create_context_auto()?;
        let _mod = Module::from_str(ptx)?;
        Ok(())
    }
}
